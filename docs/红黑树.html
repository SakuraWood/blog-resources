<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>红黑树 · Sakura&#x27;s blog</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;红黑树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#红黑树&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;红黑树&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="红黑树 · Sakura&#x27;s blog"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sakurawood.github.io/blog-resources/"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;红黑树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#红黑树&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;红黑树&lt;/h1&gt;
"/><meta property="og:image" content="https://sakurawood.github.io/blog-resources/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sakurawood.github.io/blog-resources/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/blog-resources/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sakurawood.github.io/blog-resources/blog/atom.xml" title="Sakura&#x27;s blog Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sakurawood.github.io/blog-resources/blog/feed.xml" title="Sakura&#x27;s blog Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/blog-resources/js/scrollSpy.js"></script><link rel="stylesheet" href="/blog-resources/css/main.css"/><script src="/blog-resources/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/blog-resources/"><img class="logo" src="/blog-resources/img/favicon.ico" alt="Sakura&#x27;s blog"/><h2 class="headerTitleWithLogo">Sakura&#x27;s blog</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/blog-resources/docs/doc1" target="_self">Docs</a></li><li class=""><a href="/blog-resources/docs/doc4" target="_self">API</a></li><li class=""><a href="/blog-resources/help" target="_self">Help</a></li><li class=""><a href="/blog-resources/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">红黑树</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="红黑树"></a><a href="#红黑树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>红黑树</h1>
<ul>
<li>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为&quot;对称二叉B树&quot;，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。</li>
</ul>
<p>维基百科上的定义就这么说了。好像你看了之后也不知道它究竟是啥。因为红黑树本身是非常绅士（hentai）的数据结构。</p>
<h2><a class="anchor" aria-hidden="true" id="二叉查找树"></a><a href="#二叉查找树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>二叉查找树</h2>
<p>“自平衡二叉查找树？什么是平衡树？什么是二叉查找树？”
不得不说这由红黑树引发的关于Data Structure知识匮乏的一系列惨案。。。</p>
<p>回顾一下二叉查找树吧（基础好的同学可以略过直接跳往红黑树）。它满足以下性质：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
<p>如何构造一颗二叉查找树？</p>
<!-- more -->
<p>首先一颗BST要包含插入、删除和查找等操作。</p>
<p>先定义一个节点：</p>
<pre><code class="hljs css language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,k,l=None,r=None,p=None)</span>:</span>
        self.lchild=l
        self.rchild=r
        self.parent=p
        self.key=k

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_left_child</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.lchild
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_right_child</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.rchild

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_left_child</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.parent <span class="hljs-keyword">and</span> self.parent.lchild==self

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_right_child</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.parent <span class="hljs-keyword">and</span> self.parent.rchild==self
</code></pre>
<p>初始化一棵树：</p>
<pre><code class="hljs css language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.root=<span class="hljs-literal">None</span>
        self.node_size=<span class="hljs-number">0</span>
</code></pre>
<p>此时，根节点为空，大小为0，还没开始插入节点。</p>
<p>所以，插入考虑两种情况：</p>
<ol>
<li>插入的是根节点</li>
<li>插入的不是根节点</li>
</ol>
<p>插入根节点不用多说，但插入子节点有讲究，根据二叉查找树的定义，具体看代码：</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self,x)</span>:</span>
        node= Node(x)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.root:
            self.root=node
            self.node_size=<span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            current_node=self.root
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                <span class="hljs-keyword">if</span> x&lt;current_node.key:                      <span class="hljs-comment">#x如果小于当前节点的key，则想办法弄到左边</span>
                    <span class="hljs-keyword">if</span> current_node.lchild:                 <span class="hljs-comment">#已经有了，则把比较目标切成左子树的根节点</span>
                        current_node=current_node.lchild
                    <span class="hljs-keyword">else</span>:                                   <span class="hljs-comment">#若没有，直接插入</span>
                        current_node.lchild=node
                        node.parent=current_node
                        self.node_size+=<span class="hljs-number">1</span>
                        <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">elif</span> x&gt;current_node.key:                    <span class="hljs-comment">#x大于key，则弄到右边</span>
                    <span class="hljs-keyword">if</span> current_node.rchild:                 <span class="hljs-comment">#已经有了，则把比较目标切成右子树的根节点</span>
                        current_node=current_node.rchild
                    <span class="hljs-keyword">else</span>:                                   <span class="hljs-comment">#若没有，直接插入</span>
                        current_node.rchild=node
                        node.parent=current_node
                        self.node_size+=<span class="hljs-number">1</span>
                        <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">break</span>
</code></pre>
<p>插入了之后，就可以查找节点了，查找相当简单，多亏了这是二叉排序树，你只需要从金字塔顶端往下走就行，遇上小的往左，遇上大的往右，直到碰到和自己一样的：</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self,x)</span>:</span>
        current_node=self.root
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_node:
                result=<span class="hljs-literal">None</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">elif</span> x&lt;current_node.key:
                current_node=current_node.lchild
            <span class="hljs-keyword">elif</span> x&gt;current_node.key:
                current_node=current_node.rchild
            <span class="hljs-keyword">else</span>:
                result=current_node
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> result
</code></pre>
<p>呵呵，挺好的，貌似差不多了，，，不过还有删除呢。
删除这个操作，是二叉树里最烦的操作了。它涉及到各种情况，虽然写法不一，但思路都是一样，无外乎包含这四种情况：</p>
<ol>
<li>被删节点是叶节点（不够准确，其实是既无左子树又无右子树）</li>
<li>被删节点有左子树但没有右子树</li>
<li>被删节点有右子树但没有左子树</li>
<li>被删节点左右子树都有</li>
</ol>
<p>什么？还有被删节点是根节点？嗯，确实，它可以看做是1的一种特殊情况，它本身没有子节点，同时没有父节点。</p>
<p>首先理解一下前驱和后继的含义。
节点key的前驱，就是中序遍历时，比key小的所有节点中最大的那个节点。
节点key的后继，就是中序遍历时，比key大的所有节点中最小的那个节点。</p>
<p>所以，根据定义，被删节点用前驱或者后继替代都是合法的。</p>
<p>针对这四种情况，我列几张图，说明一下：</p>
<ol>
<li>既无左子树又无右子树</li>
</ol>
<p><img src="/images/bst_1.png" alt="bst-1"></p>
<p>这俩节点都是属于这种情况，应该直接删掉。</p>
<ol start="2">
<li>有左子树但没有右子树</li>
</ol>
<ul>
<li>先解释一下，可以有两种做法，可以用左孩子节点替换，也可以用前驱节点替换，反正都符合二叉排序树的性质，我这里采用前驱节点替换：</li>
</ul>
<p><img src="/images/bst_2.png" alt="bst-2"></p>
<ol start="3">
<li>有右子树但没有左子树</li>
</ol>
<ul>
<li>同理地，可以有两种做法，可以用右孩子直接替换，也可以用后继节点替换，我这里采用了右孩子直接替换：</li>
</ul>
<p><img src="/images/bst_3.jpg" alt="bst-3"></p>
<ol start="4">
<li>既有左子树又有右子树</li>
</ol>
<ul>
<li>同样地，可以有两种做法，可以用前驱节点替换，也可以用后继节点替换，这里采用后继节点替换：</li>
</ul>
<p><img src="/images/bst_4.png" alt="bst-4"></p>
<p>代码如下：</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_successor</span><span class="hljs-params">(self,x)</span>:</span>
        node=self.find(x)
        current_node=node.rchild
        <span class="hljs-keyword">while</span> current_node.lchild:
            current_node=current_node.lchild
        <span class="hljs-keyword">return</span> current_node

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(self,x)</span>:</span>
    node=self.find(x)
    current_node=node.lchild
    <span class="hljs-keyword">while</span> current_node.rchild:
        current_node=current_node.rchild
    <span class="hljs-keyword">return</span> current_node

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self,x)</span>:</span>
    self.delete(x)
    self.node_size-=<span class="hljs-number">1</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self,x)</span>:</span>
    node=self.find(x)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">if</span> node.lchild <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.rchild:
            pre=self.get_pre(node.key)
            value=pre.key
            self.delete(value)
            node.key=value
        <span class="hljs-keyword">elif</span> node.rchild <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.lchild:
            <span class="hljs-keyword">if</span> node.is_left_child():
                node.rchild.parent=node.parent
                node.parent.lchild=node.rchild
            <span class="hljs-keyword">else</span>:
                node.rchild.parent=node.parent
                node.parent.rchild=node.rchild
        <span class="hljs-keyword">elif</span> node.lchild <span class="hljs-keyword">and</span> node.rchild:
            successor=self.get_successor(node.key)
            value=successor.key
            self.delete(value)
            node.key=value
        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> node.lchild <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.rchild:
            <span class="hljs-keyword">if</span> node.is_left_child():
                node.parent.lchild=<span class="hljs-literal">None</span>
            <span class="hljs-keyword">elif</span> node.is_right_child():
                node.parent.rchild=<span class="hljs-literal">None</span>
            <span class="hljs-keyword">else</span>:
                self.root=<span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> AttributeError
    <span class="hljs-keyword">except</span> AttributeError:
        <span class="hljs-keyword">print</span> <span class="hljs-string">"The node is not in the tree"</span>
</code></pre>
<p>大致思路就是这样，二叉排序树就这样介绍完了。</p>
<p>来分析一波时间复杂度，按照二叉排序树的性质，只要是中序遍历，那肯定会生成一个有序序列。因为时间复杂度只与二叉树的深度有关，如果刚好这棵树的深度和节点数量一样（起始就是升序插入），那和顺序查找（时间复杂度O(n)）没有区别=。=，这就杯具了。但乐观点讲，假入这个二叉排序树初始化的特别巧妙，恰好最后变成了一颗完全二叉树，岂不妙哉（时间复杂度O(logn)）？</p>
<p>该如何确保它变成这样呢？所以有了平衡的概念，看来前人为了方便查找可谓是煞费苦心。</p>
<h2><a class="anchor" aria-hidden="true" id="平衡二叉树"></a><a href="#平衡二叉树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>平衡二叉树</h2>
<p>平衡二叉树是优化后的二叉排序树，在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。
还是举个例子吧。</p>
<h3><a class="anchor" aria-hidden="true" id="avl树"></a><a href="#avl树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AVL树</h3>
<p>AVL树，毫无疑问，典型中的典型。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<p>“Wtf？平衡因子？树旋转？什么玩意儿？”</p>
<p>这么说吧，树旋转操作是把一颗普通排序树变为平衡树的核心操作，而这个操作要根据平衡因子来判断。这就跟节点删除一样，考虑的情况多，而且更加复杂。不过先不用急，慢慢来：</p>
<p>我们先来看张图：</p>
<p><img src="/images/tree_rotate.jpg" alt="avl-1"></p>
<p>通过上面操作，树趋于平衡。究竟是什么操作？就是通过树旋转操作。</p>
<p>树旋转操作有四种情况：</p>
<ul>
<li>LL型
先来张图体会一下：
<img src="/images/tree_rotate_ll.jpg" alt="avl-2"></li>
</ul>
<p>可以看到，50的平衡因子超过了1，不平衡，需要调整。这是什么类型？这是在不平衡节点的左子树的左子树上发生的事情。所以，它是LL型。
结合上图说明，它要做的工作有两步：</p>
<ol>
<li>以50的左孩子23为中心，右旋转；</li>
<li>23的右子树被移动当作50的左子树（无右子树情况下，无需这一步）</li>
</ol>
<ul>
<li>RR型</li>
</ul>
<p><img src="/images/tree_rotate_rr.jpg" alt="avl-3"></p>
<p>同理地，RR型旋转要做的工作：</p>
<ol>
<li>以50的右孩子60为中心，左旋转；</li>
<li>60的左子树被移动当作50的右子树（无左子树情况下，无需这一步）</li>
</ol>
<p>LL型和RR型都还算是比较简单的。后面来俩复杂点的，先看图：</p>
<p><img src="/images/tree_rotate_2.png" alt="avl-4"></p>
<p>这怎么搞？如果你直接右旋转的话，你会发现将不符合排序树的性质，因为32比23大了。为什么会这样呢，因为32是23的右子树啊。这事情发生在不平衡节点的左子树的右子树上，所以它叫LR型。</p>
<ul>
<li>LR型
接着上面的图说明，要解决LR型的旋转还是有点套路的，如果把50的左子树变形成LL型那样的就好了。是，就这样做。</li>
</ul>
<p><img src="/images/tree_rotate_lr.jpg" alt="avl-5"></p>
<p>先解决左子树姿势不正确的问题，然后你发现可以直接右旋了。</p>
<p><img src="/images/tree_rotate_lr_2.jpg" alt="avl-6"></p>
<ul>
<li>RL型</li>
</ul>
<p>看懂了LR型，再来看RL型，那就是如法炮制了。
先解决右子树姿势问题，再左旋。
<img src="/images/tree_rotate_rl.jpg" alt="avl-7"></p>
<p>知道怎么解决平衡了。还有一个困扰的问题是，如何检测不平衡的发生，这个事情发生在插入节点甚至删除节点的时候。事实上只需检测不平衡的最小子树就行了，因为不平衡是建立在已平衡基础上的。所以只需要向上查找不平衡的节点就可以了。</p>
<p>上面的二叉排序树还派的上用场，先改造一下：</p>
<pre><code class="hljs css language-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_balance</span><span class="hljs-params">(self,node)</span>:</span>                     <span class="hljs-comment">#判断是否平衡</span>
        bf=self.get_bf(node)
        <span class="hljs-keyword">if</span> bf&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> bf&lt;<span class="hljs-number">-1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_bf</span><span class="hljs-params">(self,node)</span>:</span>                      <span class="hljs-comment">#获取一个节点的平衡因子</span>
        lh=self.get_node_h(node.lchild)
        rh=self.get_node_h(node.rchild)
        <span class="hljs-keyword">return</span> lh-rh

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_h</span><span class="hljs-params">(self,node)</span>:</span>                  <span class="hljs-comment">#获取一个节点的高度,这里的高度不是指节点所在的层数</span>
        <span class="hljs-keyword">return</span> self.get_node_h_helper(node)<span class="hljs-number">-1</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_h_helper</span><span class="hljs-params">(self,node)</span>:</span>           <span class="hljs-comment">#获取高度的辅助函数</span>
        l,r=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> node:
            l=self.get_node_h_helper(node.lchild)
            r=self.get_node_h_helper(node.rchild)
        <span class="hljs-keyword">return</span> l+<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> l&gt;r <span class="hljs-keyword">else</span> r+<span class="hljs-number">1</span>
</code></pre>
<p>有了上面的函数，我们就可以根据是否平衡来进行树旋转操作了。（朋友们有没有更好的判断平衡的方法？）
下面实现四种插入的情况：</p>
<pre><code class="hljs css language-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tree_rotate_ll</span><span class="hljs-params">(self,node)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:
            self.root=node.lchild
            node.lchild.parent=<span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:
            node.lchild.parent=node.parent
            <span class="hljs-keyword">if</span> node.is_left_child():
                node.parent.lchild=node.lchild
            <span class="hljs-keyword">else</span>:
                node.parent.rchild=node.lchild
        temp_node=node.lchild.rchild        <span class="hljs-comment">#记住左节点的右节点（孩子）</span>
        node.lchild.rchild=node
        node.parent=node.lchild
        <span class="hljs-keyword">if</span> temp_node:                       <span class="hljs-comment">#如果该节点不为空，则把它的父亲置为需要调整的节点</span>
            temp_node.parent=node
        node.lchild=temp_node               <span class="hljs-comment">#需要调整的节点的左孩子设成刚刚记住的节点（孩子）</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tree_rotate_rr</span><span class="hljs-params">(self,node)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:
            self.root=node.rchild
            node.rchild.parent=<span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:
            node.rchild.parent=node.parent
            <span class="hljs-keyword">if</span> node.is_left_child():
                node.parent.lchild=node.rchild
            <span class="hljs-keyword">else</span>:
                node.parent.rchild=node.rchild
        temp_node=node.rchild.lchild        <span class="hljs-comment">#记住右孩子的左节点（孩子）</span>
        node.rchild.lchild=node
        node.parent=node.rchild             
        <span class="hljs-keyword">if</span> temp_node:                       <span class="hljs-comment">#节点不为空，则把它的父亲置为需要调整的节点</span>
            temp_node.parent=node
        node.rchild=temp_node               <span class="hljs-comment">#需要调整的节点的右孩子设成刚刚记住的节点（孩子）</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tree_rotate_lr</span><span class="hljs-params">(self,node)</span>:</span>
        node.lchild.rchild.parent=node              <span class="hljs-comment">#操作较为繁杂，仔细品味，有指针的话更好理解</span>
        temp_node=node.lchild.rchild.lchild         <span class="hljs-comment">#记住左孩子的右孩子的左孩子，为啥，请看图</span>
        node.lchild.rchild.lchild=node.lchild       
        node.lchild=node.lchild.rchild
        node.lchild.lchild.rchild=<span class="hljs-literal">None</span>              <span class="hljs-comment">#先置空</span>
        node.lchild.lchild.parent=node.lchild
        <span class="hljs-keyword">if</span> temp_node:
            temp_node.parent=node.lchild.lchild
            node.lchild.lchild.rchild=temp_node     <span class="hljs-comment">#赋给左孩子的左孩子的右孩子</span>
        self.tree_rotate_ll(node)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tree_rotate_rl</span><span class="hljs-params">(self,node)</span>:</span>
        node.rchild.lchild.parent=node
        temp_node=node.rchild.lchild.rchild         <span class="hljs-comment">#记住右孩子的左孩子的右孩子</span>
        node.rchild.lchild.rchild=node.rchild
        node.rchild=node.rchild.lchild
        node.rchild.rchild.lchild=<span class="hljs-literal">None</span>              <span class="hljs-comment">#先置空</span>
        node.rchild.rchild.parent=node.rchild
        <span class="hljs-keyword">if</span> temp_node:
            temp_node.parent=node.rchild.rchild
            node.rchild.rchild.lchild=temp_node     <span class="hljs-comment">#赋给右孩子的右孩子的左孩子</span>
        self.tree_rotate_rr(node)
</code></pre>
<p>这样，四种类型的旋转也完成了（在码这四种操作的时候头有点晕=。=），好像差不多了。但事实还有一步，就是如何知道不平衡时采用哪种旋转，我看了很多博客，几乎都没有提到这一点。也许是觉得太简单了，略过了=。=
所以，在这里再分析一下旋转类型的判断,具体看代码注释：</p>
<pre><code class="hljs css language-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_imbanlance</span><span class="hljs-params">(self,node)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_balance(node):
            <span class="hljs-keyword">if</span> self.get_bf(node)&gt;<span class="hljs-number">1</span>:                    <span class="hljs-comment">#如果平衡因子大于1，那肯定是LL或者LR</span>
                <span class="hljs-keyword">if</span> self.get_node_h(node.lchild.lchild)&gt;self.get_node_h  (node.lchild.rchild):               <span class="hljs-comment">#左子树的左子树高度大于左子树的右子树，可以判定为LL</span>
                    self.tree_rotate_ll(node)
                <span class="hljs-keyword">else</span>:                               <span class="hljs-comment">#小于则为LR</span>
                    self.tree_rotate_lr(node)
            <span class="hljs-keyword">else</span>:                                       <span class="hljs-comment">#平衡因子小于1，那肯定是RR或者RL</span>
                <span class="hljs-keyword">if</span> self.get_node_h(node.rchild.rchild)&gt;self.get_node_h(node.rchild.lchild):                <span class="hljs-comment">#右子树的右子树高度大于右子树的左子树，可以判定为RR</span>
                    self.tree_rotate_rr(node)
                <span class="hljs-keyword">else</span>:                               <span class="hljs-comment">#小于则为RL</span>
                    self.tree_rotate_rl(node)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">pass</span>
</code></pre>
<p>实力分析一波：
只有在插入和删除的时候，才会出现不平衡。一切都建立在二叉查找树的插入和删除操作上。</p>
<ul>
<li>插入
插入的时候，因为整棵树事先是平衡的，所以只需要往上查找不平衡的节点就行，然后根据类型执行旋转操作。</li>
</ul>
<p>插入还好，最多也就两次旋转。因为插入的时候，只根据某一个节点进行调整。</p>
<ul>
<li>删除
删除就不一样了,先按照普通的BST进行删除，而这个时候就需要进行平衡检查，怎么个检查法？插入的时候，好歹节点是插进来的，可以根据它往上查找，但删除节点后，节点都不存在了，怎么检查呢？</li>
</ul>
<p>可以明确的一点是：
假如一个节点被删除，那替代它之后的节点以及往上的父啊祖啊什么的节点，平衡因子都可能发生变化。
“嘿嘿，难道不是像插入那样，找到第一个不平衡的然后调整完不就得了？”</p>
<p>其实，你在找到第一个不平衡的节点调整完之后，只是局部调整好了。来张图你就懂了：
<img src="/images/avl_delete_1.jpg" alt="avl-8"></p>
<p>然后你调整完之后，变成了这样
<img src="/images/avl_delete_2.jpg" alt="avl-9"></p>
<p>“本来就应该这样，这不很好吗？”</p>
<p>但是你发现这所谓局部的子树，高度已经发生了变化，由5变成了4。
你想一下，要是它的爸爸的另一个孩子，也就是它兄弟那边，高度是6（按照定义符合AVL树），造成了爸爸的平衡因子超过2，这可咋整？然后你又要调。
更糟糕的是，调完后又发现爷爷又不平衡了，所以继续。。。如此，直到根节点（这是最坏情况）。</p>
<p>所以，删除对于AVL树来说是一个糟心的过程。而且，删除一个节点很容易就造成整棵树的不平衡，造成调整多次。</p>
<p>由此，在原来BST的基础上，添加调整平衡的代码：</p>
<pre><code class="hljs css language-python">    <span class="hljs-comment">#插入</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self,x)</span>:</span>
        self.insert_helper(x)
        node=self.find(x)
        self.check_imbanlance(node)
</code></pre>
<pre><code class="hljs css language-python">    <span class="hljs-comment">#删除</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self,x)</span>:</span>
        node=self.find(x)
        self.delete(node)
        need_to_check_balance=node          <span class="hljs-comment">#先保存当前节点</span>
        <span class="hljs-keyword">while</span> need_to_check_balance:        
            temp_parent=need_to_check_balance.parent        <span class="hljs-comment">#向上不断检查</span>
            self.check_imbanlance(need_to_check_balance)
            need_to_check_balance=temp_parent
        self.node_size-=<span class="hljs-number">1</span>
</code></pre>
<p>终于把AVL树一步一步给实现了，长舒一口气。感觉AVL树已经让你很疲倦了，但是，红黑树还没有开始。</p>
<p>为什么要有红黑树？AVL树跟红黑树比差哪了？</p>
<p><strong>刚才在AVL树中，已经看到AVL树的删除操作在最坏情况下，调整的次数是O(logn)</strong></p>
<p>AVL树在红黑树面前，几乎就是小巫见大巫，做好心理准备吧，见识见识这真正变态级的数据结构：</p>
<h2><a class="anchor" aria-hidden="true" id="再遇红黑树"></a><a href="#再遇红黑树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>再遇红黑树</h2>
<p>就像练了级回来再次挑战一样，我想这次已经有了足够了的资本。</p>
<h3><a class="anchor" aria-hidden="true" id="红黑树的性质"></a><a href="#红黑树的性质" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>红黑树的性质</h3>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p>红黑树为什么变态？
因为你就算埋头看个几天，甚至都没搞清楚它，即使你记下了步骤，依然不知所以。看红黑树，就是硬着头皮看的。</p>
<p>所以，为了避免懵逼。还是先入手一下2-3树或者2-3-4树。</p>
<p>“怎么还不讲红黑树，之前就已经绕过一次了，这是要干嘛？”</p>
<p>没办法，直接讲红黑树，就算看懂了，很快就忘了，因为你根本不知道它的意义。它究竟为谁而生？</p>
<h2><a class="anchor" aria-hidden="true" id="2-3tree"></a><a href="#2-3tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2-3Tree</h2>
<p>2-3树对于人类思维来讲非常好理解（表骗我）。你先别问2-3树的好处是啥，它在我这里，只是理解红黑树的一个工具。
注意，它不是二叉树了，但它是二叉排序树的一种泛化版。它由2-节点跟3-节点构成。</p>
<ul>
<li>定义：</li>
</ul>
<ol>
<li>要么空，要么就是这样：</li>
<li>对于2-node，它有一个键值key，和两个子节点（左、右）。左节点是一个2-3节点，它里面的元素都比key要小；右节点也是一个2-3节点，它里面的元素都比key要大。</li>
<li>对于3-node，它有两个键值A和B，以及三个子节点（左、中、右）。左节点是一个2-3节点，它的元素比A都要小；中节点是一个2-3节点，它的元素的值介于A和B之间；右节点也是一个2-3节点，它的元素比B都要大。</li>
</ol>
<p>叶节点的孩子节点为空（null links）。</p>
<p>直接上《算法》里的图：
<img src="/images/2-3_tree_1.png" alt="2-3_tree-1"></p>
<p>一颗完美的2-3树，它到所有null links的距离都是一样的。</p>
<p>诶，我们要讲就要讲完美的，其他的不谈。</p>
<h3><a class="anchor" aria-hidden="true" id="2-3tree查找"></a><a href="#2-3tree查找" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2-3Tree查找</h3>
<p>查找就不用说了吧？跟BST是一个道理，从祖宗开始往下查，有则有，无则无。
《算法》里的图很形象：
<img src="/images/2-3_tree_2.png" alt="2-3_tree-2"></p>
<h3><a class="anchor" aria-hidden="true" id="2-3tree插入"></a><a href="#2-3tree插入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2-3Tree插入</h3>
<p>套路都差不多了，插入都是基于查找。</p>
<ul>
<li>往2-node里插</li>
</ul>
<p>如果插入一个节点时，查询刚好终止于一个2-node，那么很幸运，这个很好操作，只需要将这个2-node变成一个3-node即可：</p>
<p><img src="/images/2-3_tree_3.png" alt="2-3_tree-3"></p>
<ul>
<li>往3-node里插</li>
</ul>
<p>但是往3-node里面插入节点就没那么友好了，可以说，相当复杂：</p>
<ul>
<li>插入的3-node是一个由独立的3-node所构成的树
这个还相对简单点，先把它变成一个暂时的4-node：</li>
</ul>
<p><img src="/images/2-3_tree_4.png" alt="2-3_tree-4"></p>
<p>然后分割这个4-node，中间那个推上去，把这个4-node变成一颗2-3树：
<img src="/images/2-3_tree_5.png" alt="2-3_tree-5"></p>
<ul>
<li>插入的3-node的父节点是一个2-node</li>
</ul>
<p>第一步，还是先把它变成一个暂时的4-node：</p>
<p><img src="/images/2-3_tree_6.png" alt="2-3_tree-6"></p>
<p>然后，分割这个4-node，把中间那个推上去：
<img src="/images/2-3_tree_7.png" alt="2-3_tree-7"></p>
<ul>
<li>插入的3-node的父节点是一个3-node</li>
</ul>
<p>第一步，把它变成一个4-node：
<img src="/images/2-3_tree_8.png" alt="2-3_tree-8"></p>
<p>然后，分割，推中：
<img src="/images/2-3_tree_9.png" alt="2-3_tree-9"></p>
<p>然后你发现，这一推，父节点也变成4-node了。咋办？那就继续推中：</p>
<p><img src="/images/2-3_tree_10.png" alt="2-3_tree-10"></p>
<ul>
<li>根节点是4-node</li>
</ul>
<p>推中推的很爽，结果发现王座变成了4-node。其实这个跟上种情况一样，继续推中，推出一个新的根节点：</p>
<p><img src="/images/2-3_tree_11.png" alt="2-3_tree-11"></p>
<p>所以，在插入元素到3-node的时候，暂时生成的4-node“推中”是一个有讲究的操作。总结一下“推中”到底能遇上哪些情况：</p>
<ul>
<li><p>根节点“推中”
<img src="/images/2-3_tree_12.png" alt="2-3_tree-12"></p></li>
<li><p>“推中”的对象是2-node
有两种情况：</p></li>
</ul>
<ol>
<li>4-node是2-node的左子树，这个推到2-node左边；</li>
<li>4-node是2-node的右子树，这个推到2-node右边；</li>
</ol>
<p><img src="/images/2-3_tree_13.png" alt="2-3_tree-13"></p>
<ul>
<li>“推中”的对象是3-node
有三种情况：</li>
</ul>
<ol>
<li>4-node是3-node的左子树，这个推到3-node左边；</li>
<li>4-node是3-node的中子树，这个推到3-node中间；</li>
<li>4-node是3-node的右子树，这个推到3-node右边；</li>
</ol>
<p><img src="/images/2-3_tree_14.png" alt="2-3_tree-14"></p>
<p>看完上面的东西，有什么值得注意的吗？
<strong>可以知道，2-3树在单纯插入的时候高度是不会变的，变是变在“推中”的操作上。而且，它时刻都在保持着完美平衡。因为它完美平衡，所以插入操作始终发生在底部。</strong>
完美平衡的好处之一就是查找快。这不用说了吧？
“AVL也快啊~~”
是，我之前说什么来着，AVL它删除可能会很耗时，旋转太多！2-3树一看上去都不用旋转，是不是6翻了？
那好吧，就来实现实现。
根据以上的规则，可以写出一堆代码出来，它对代码实现不是很友好。你可能觉得挺简单的，但事实上，涉及到了两种节点，在考虑情况的时候就很头疼。能不能只靠一种节点来实现，不要这些什么2-节点、3-节点，甚至4-节点的，写出来就感觉麻烦。</p>
<h2><a class="anchor" aria-hidden="true" id="2-3树到红黑树"></a><a href="#2-3树到红黑树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2-3树到红黑树</h2>
<p>终于到了红黑树了，这次不会再绕弯了。</p>
<p>其实，看完这些，估计心里就有些想法了，红黑树该不会是2-3树进化过来的吧？
呃，这谈不上是进化，只能说红黑树是单纯的二叉树实现了2-3树。</p>
<p>“逗我呢，这哪是二叉？那开三叉的3-节点怎么搞？”</p>
<p>对，我要说的就是3-节点要怎么搞，我们要对3-节点进行一下处理，《算法》书上说叫对3-节点进行编码。</p>
<p><img src="/images/rbt_1.png" alt="rbt-1"></p>
<p>如同书上所说，一个3-node，它变成了两个2-node。<strong>之前的3-node的左元素被抽离出来，变成了3-node的右元素的左节点。</strong>并且这两个2-node由红线相连。把2-3树里的所有3-node都变成这样，就成了一个红黑树的雏形。为什么只是雏形？因为描述边的特点没有描述节点来的方便。我们加点料看看。</p>
<p>理解刚才那句<strong>“3-node的左元素被抽离出来，变成了3-node的右元素的左节点”</strong>是很重要的。根据书上描述，这里要定义3-node的右元素为h节点：</p>
<p><img src="/images/rbt_2.png" alt="rbt-2"></p>
<p>并且，还有两件重要的事，直接说明了红、黑节点究竟是怎么着色的：</p>
<ol>
<li>h节点的左节点为红节点；</li>
<li>h节点的右节点为黑节点；
此外，空链接根据约定，也为黑节点。</li>
</ol>
<p>怎么样？总算知道了吧？红黑树的红与黑不是在变戏法（有些同志像介绍戏法一样介绍红黑树，怎么看得懂？），它只是约定俗成而已。
再来看看红黑树的五条性质：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p>1、3都不必说了（第二条性质待会儿再说）。其实，有些人好奇就好奇在为什么有4、5这样的性质。现在，就给你分析一波：</p>
<ul>
<li><p>为啥不能有两个连续的红色节点？
如刚才的图，h节点是3-节点的右元素，只有3-节点的左元素才有变成红节点的条件；如果h节点也想变红，除非它还有个兄弟在它右边，但是如果它还有右兄弟的话，那这个节点就不是3-节点，而是4-节点了（注意这里的描述，h节点不是不可以变红，只是它暂时会变红，就跟2-3树里会有临时的4-node一样）。</p></li>
<li><p>为啥所有路径上的黑色节点数量一样？
先想一下2-3树，它到所有叶节点的距离都是一样的。再想想红节点是怎么出来的？红节点是3-节点的左元素分离出来的，并且用红线跟h节点相连。对于2-3树来说，红线是不是多余的东西？剩下的自然就都是黑线了啊，红线和红节点在2-3树这个层面上来说，影响不到2-3树的高度。可能说的有点不明白，那下图绝对能让你明白：</p></li>
</ul>
<p><img src="/images/rbt_3.png" alt="rbt-3"></p>
<p>那么接下来，就是红黑树的神级操作。唯一会让你困扰的是，红黑树在处理插入3-node（相对于等价的2-3树）的时候，不是采取“推中”的策略，而是“分裂”的策略（从这里的理解开始，我跟《算法》里的描述可能有些许不一样，但总归来讲思想还是一样的）。</p>
<p>我要引导的是，如何从2-3树的概念里转换过来：
依然像2-3树那样进行插入操作。所以，在下面的描述里，关于2-node，3-node，4-node这些，只是红黑树里等价于对应2-3树的说法。</p>
<h3><a class="anchor" aria-hidden="true" id="树旋转操作"></a><a href="#树旋转操作" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>树旋转操作</h3>
<p>介绍红黑树的插入之前，我想先介绍一下树旋转。但是为了更好地理解，先来个插入操作作为引子。</p>
<h4><a class="anchor" aria-hidden="true" id="往独立的2-node里面插-只有root节点"></a><a href="#往独立的2-node里面插-只有root节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>往独立的2-node里面插（只有root节点）</h4>
<p>2-3树的2-node：
<img src="/images/rbt_4.png" alt="rbt-4"></p>
<p>红黑树的2-node：
<img src="/images/rbt_5.png" alt="rbt-5"></p>
<ul>
<li>插入一个相对于b小的元素a：
2-3树：
<img src="/images/rbt_6.jpg" alt="rbt-6"></li>
</ul>
<p>红黑树：
<img src="/images/rbt_7.jpg" alt="rbt-7"></p>
<p>这一步，显然，对照一下2-3树，2-3树的2-node变成了3-node，而3-node显然要编码成红黑树的标准。b成为所谓的h节点，a作为它的左节点，当然也就是红线相连，并且a节点标成红色。</p>
<ul>
<li>插入一个相对于b大的元素c:
2-3树：
<img src="/images/rbt_8.jpg" alt="rbt-8"></li>
</ul>
<p>红黑树：
<img src="/images/rbt_9.jpg" alt="rbt-9"></p>
<p>“嘿嘿嘿，你怎么乱搞？”
这不是乱搞，首先，我们得按照二叉排序树的规定来插入节点。
“插入就插入，为啥把它搞成红的？不是说只有左元素才有这个条件吗？”
红的是因为要符合红黑树的第五条性质。
“那不矛盾了？”
先别急，我还得旋转它呢：
<img src="/images/rbt_10.jpg" alt="rbt-10"></p>
<p><strong>明确一点，红黑树的插入操作还是按照二叉排序树的套路来（不然之前复习过的都白费了不是吗=。=），默认插入的节点是红节点。产生冲突了（和红黑树定义违背）再进行树旋转和变色操作。</strong></p>
<p>上面的例子里，就出现了需要调整的情况，《算法》上总结了两种旋转操作：</p>
<ul>
<li>左旋转
<img src="/images/rbt_11.jpg" alt="rbt-11"></li>
</ul>
<ul>
<li>右旋转
<img src="/images/rbt_12.jpg" alt="rbt-12"></li>
</ul>
<p>“为什么还会有右旋转？(对啊，我也想问)。这不是把本来正确的给整成错的了吗？”</p>
<ul>
<li>变色
呵呵，上面我已经说过，那个所谓的h节点不是不可以变红，当它是4-node的中间节点是，它会是红的，所以这个右旋转其实是起到一个过渡作用，看下面的情况：
<img src="/images/rbt_14.jpg" alt="rbt-13"></li>
</ul>
<p>你看，我想插入a（b已经红了），那它就得在b左边，形成一个临时的4-node，而对于临时的4-node，是需要“推中”的，在红黑树里，其实就是LL旋转（b为中心）：
<img src="/images/rbt_15.jpg" alt="rbt-14"></p>
<p>“这下左右都是红的了，还搞毛。。。”
忘了4-node怎么拆分的了吗？，把b节点推上去，4-node变成3个2-node，放在红黑树的概念里，自然也就没有所谓的红节点了：
<img src="/images/rbt_16.jpg" alt="rbt-15"></p>
<p>注意图中的最后一步，我把b节点变红了。你应该可以理解，因为中间状态的时候，这个子树的黑色层级变高了，不符合红黑树的第五条性质。</p>
<p><strong>但是，在b节点是根节点的情况下，不能变色，而且你即使翻转它的颜色，也是个多余动作。</strong>根节点是红或黑，都影响不到红黑树的第五条性质。而且，你可以想一下，根节点如果设成红色，就没法往下进行了。所以，<strong>保持根节点是黑色的</strong>。这也就是红黑树为什么有第二条性质。</p>
<p>“b不是根节点的话，如果b节点本身是左边的子节点还好，如果是右边的子节点，又得左旋转。”
嗯，是的。这里的插入操作，有时候需要多次旋转，最多三次旋转。
至于这些旋转操作，前面已经介绍过AVL树的旋转操作，所以这里不再重复介绍（就多了根红线嘛。。看前面的LL、LR、RR、RL去）</p>
<h3><a class="anchor" aria-hidden="true" id="插入操作"></a><a href="#插入操作" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>插入操作</h3>
<p>上面已经提到过一种插入操作，下面继续，要知道，红黑树的插入除了发生在根节点，就是在叶节点了。</p>
<h4><a class="anchor" aria-hidden="true" id="往底部的2-node插入"></a><a href="#往底部的2-node插入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>往底部的2-node插入</h4>
<p><img src="/images/rbt_13.jpg" alt="rbt-16"></p>
<p>和在根节点插入差不多，只不过有父节点存在而已。</p>
<p>下面，往3-node里面插入，和2-3树一样，很多种情况：</p>
<h4><a class="anchor" aria-hidden="true" id="一个单独的3-node"></a><a href="#一个单独的3-node" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一个单独的3-node</h4>
<p><img src="/images/rbt_18.png" alt="rbt-17"></p>
<h4><a class="anchor" aria-hidden="true" id="往底部的3-node插入"></a><a href="#往底部的3-node插入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>往底部的3-node插入</h4>
<p><img src="/images/rbt_17.png" alt="rbt-18"></p>
<p>有时候旋转最多要三次，就是如下这种情况（为啥不是两次？两次也是对的，马上就讲）：
<img src="/images/rbt_19.png" alt="rbt-19"></p>
<p>好了，我算是把《算法》上的2-3树到红黑树基本复述了一遍。
“诶，貌似没讲完，还有删除操作呢？”</p>
<p>先打断一下，你可能会发现，2-3树概念里的红黑树，虽然处处符合红黑树的5条性质，但总感觉不够。而且你如果之前看过其他的博客，你会发现跟大多数讲的不一样，你肯定会提出质疑：
上面实现的红黑树，如果节点没有左子树，往右边插入，就一定会调整到左边，因为它不符合所谓的red link（2-3树）定义。但事实上，红节点在右边又怎么了？没毛病啊，根本不会违背红黑树的性质。红色节点通通都是左节点，强行右转左的操作让你很不爽。
所以，你觉得这可能是劣化版的红黑树。</p>
<p>我当然知道你在想什么，2-3-4树，对不对？是的，2-3-4树才是红黑树的对应版本，为什么不早点说？其实本质是一样的，所以，这里就是个玄学问题（笑）。区别在4-node，看下图：
<img src="/images/rbt_20.png" alt="rbt-20"></p>
<p><strong>关键是你怎么看待4-node，2-3树里也会有4-node，只不过它是暂时存在的，“推中”是它的核心操作；对于2-3-4树来说，又是怎样一副景象呢？在遇上4-node的时候，难道还要生成一个临时的5-node吗？并不是，在这个时候，它需要先“分裂”成3个2-node（其实就是2-3树的“推中”）。所以，一切取决于你是选择他“推中”还是“分裂”，英文原话叫“bottom-up 2-3”跟“top-down 2-3-4”。</strong></p>
<p>事实上，我讲的这个版本的红黑树，它不是劣化版本，反而更加高级。它是红黑树的发明人之一<code>Robert Sedgewick</code>先生为了减少原有红黑树插入/删除需要处理的情况数量，自己改进的算法，它叫<code>Left-leaning red-black trees</code>（LLRBT），即左偏红黑树。在它的世界里，红节点就是要左倾的。它比起一般的RBT，有以下优点：</p>
<ul>
<li>它可以与2-3-4树保持完美的一一对应</li>
<li>它可以保持完美的黑链平衡</li>
</ul>
<p>我在这里稍微提一提2-3-4树吧，2-3-4树允许树中有这样的节点：</p>
<ul>
<li>2-node：一个key，2个孩子</li>
<li>3-node：两个key，3个孩子</li>
<li>4-node：三个key，4个孩子
<img src="/images/rbt_23.png" alt="rbt-21"></li>
</ul>
<p>普通RBT编码方式：
<img src="/images/rbt_21.png" alt="rbt-22"></p>
<p>3-node的编码方式跟刚才不一样了，红线可以在左，可以在右。4-node作为合法存在，它的两个子节点都可为红。</p>
<p>LLRBT编码方式：
<img src="/images/rbt_25.png" alt="rbt-23"></p>
<p>3-node的编码方式就是我上面讲的，它不允许红节点存在于右边。而关于4-node，你可以看上面讲的变色操作。所以，你明白了，我其实一直在讲的就是这个LLRBT。</p>
<h3><a class="anchor" aria-hidden="true" id="删除操作"></a><a href="#删除操作" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除操作</h3>
<p>插入都这么艰难了，删除岂不更加费脑？红黑树的删除包含哪几种情况呢？我不会去分析那些什么父黑叔红，父红叔红各种情况的，那样只会让人眼花缭乱。明明都讲了2-3树，还要各种记红啊黑什么的，那我讲2-3树有何用？</p>
<p>在LLRBT里，删除一个节点，比插入还简单，我在这里提供一个策略：</p>
<ol>
<li>找到被删节点的后继节点</li>
<li>后继节点的key替换被删节点的key</li>
<li>删除后继节点</li>
</ol>
<p>套路听上去跟普通的BST差不多，没错，就是一样，删一个节点，就是找到后继节点，把key替换掉，然后删掉后继节点。只不过你要进行变色而已。晕~~</p>
<p>明确一点，<strong>删除一个红节点不会影响到红黑树的性质。</strong>不是吗？
“那我删的后继节点就是黑的怎么办？”
“把它变成红的。”</p>
<p>黑的是啥？黑的在2-3树里就是2-node，普通节点。红的是啥？红的存在于2-3树里的3-node，也可以暂时存在于4-node。如果我删的是黑节点，也就是2-node，那我就要想办法把它变成4-node来进行删除。</p>
<p>“WTF？黑的变红的很容易啊，三个黑的组一块，变成一个4-node不就完了？”</p>
<p>是啊，我就是要利用临时的4-node。不过，你还需要考虑，你是从别的层级借过来黑节点，这意味着，这颗子树的黑链长度遭到改变，有可能就破坏了整棵树的黑链平衡。我事先想强调的一点是，对于普通的红黑树，3-node的编码，左红或者右红都是没什么区别的，这一点影响不到红黑树的第五条性质。我们同样可以利用这一点。</p>
<p>“噢，那要怎么做？”</p>
<p>所以，意思就是利用同构的特点以及暂时的4-node对二叉树进行旋转加变色，但要始终保持黑链平衡。</p>
<p>先看图，之后再解释：</p>
<p><img src="/images/rbt_27.jpg" alt="rbt-24"></p>
<p>假如我要删掉这颗树（或者只是颗子树）的最小节点a，就从它的根节点开始往下逐层“加红”（其实就是利用暂时的4-node不断往下迁移），这样做是为了先保持黑链平衡，满足红黑树的第五条性质。等删掉之后，再通过旋转恢复成LLRBT的样子。</p>
<p>“哪有你这么理想，你这例子全是黑节点啊”</p>
<p>确实，情况还是有好几种的。</p>
<p>什么时候需要加红（变成临时的4-node）？在寻找后继节点的道路上，得分两种情况讨论。</p>
<p>先提个醒，在删除后继节点的时候，肯定是这种形态：</p>
<p><img src="/images/rbt_31.jpg" alt="rbt-25"></p>
<p>完美删除，丝毫不影响红黑树的性质。</p>
<h4><a class="anchor" aria-hidden="true" id="查找路线在左子树"></a><a href="#查找路线在左子树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找路线在左子树</h4>
<p>也就是查找时，判断在左子树，需要“左拐”。</p>
<ul>
<li>情况一</li>
</ul>
<p><img src="/images/rbt_30.png" alt="rbt-26"></p>
<p>到达R节点时，因为查找的节点比R小，所以要左拐，但是看到E是红的，这种情况下，就不需要加红了嘛。直接往下走就行。</p>
<ul>
<li>情况二</li>
</ul>
<p><img src="/images/rbt_29.jpg" alt="rbt-27"></p>
<p>查找依然往左拐，但是看到C是黑的，如果此时直接对C动手，E的黑链就崩坏了，所以要它进行“加红”，公平起见，C和S都要变红。</p>
<ul>
<li>情况三</li>
</ul>
<p>情况三比情况二复杂点：</p>
<p><img src="/images/rbt_32.jpg" alt="rbt-28"></p>
<p>就是在给S变红时，S的左儿子是红的，这种情况跟插入时情况很像，只能旋转解决。</p>
<h4><a class="anchor" aria-hidden="true" id="查找路线在右子树"></a><a href="#查找路线在右子树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找路线在右子树</h4>
<p>可能拐着拐着，发现要往右子树拐了：</p>
<ul>
<li>情况一</li>
</ul>
<p><img src="/images/rbt_28.jpg" alt="rbt-29"></p>
<p>按照LLRBT的道理，右节点可能为红吗？反正先不管，先把R的两儿子都变红了再说。但偏偏遇上左节点已经红了，你说把右节点变红吧，黑链又崩坏了。所以就是这种情况，而且发生在根节点上，只需把它左红转换成右红，这样做依然不影响红黑树的性质。</p>
<ul>
<li>情况二</li>
</ul>
<p><img src="/images/rbt_33.jpg" alt="rbt-30"></p>
<p>这种简单，直接变色就行。</p>
<ul>
<li>情况三</li>
</ul>
<p><img src="/images/rbt_34.jpg" alt="rbt-31"></p>
<p>这种情况就是你发现当把E的左节点C变红了之后，C的左节点A居然是红的，这一变彻底违反红黑树性质，又得调，旋转，再变色。</p>
<p>总之，删除中所需要的临时形态就是这么多了，千万记住一点，临时操作虽说是临时，也不是LLRBT的形态，但也不能违背红黑树性质。失去了LLRBT的形态不要紧，只要你熟悉插入操作，那些什么右红变左红，4-node的“推中”，不是分分钟的事嘛。</p>
<p>最后，还是来份完整代码吧，也是根据《算法》的程序，写了个python版的：</p>
<pre><code class="hljs css language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,k,v,c=RED,l=None,r=None)</span>:</span>
        self.lchild=l
        self.rchild=r
        self.key=k
        self.color=c
        self.value=v

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red_black_tree</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.root=<span class="hljs-literal">None</span>
        self.node_size=<span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_red</span><span class="hljs-params">(self,node)</span>:</span>
        <span class="hljs-keyword">if</span> node:
            <span class="hljs-keyword">return</span> node.color
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span><span class="hljs-params">(self,k,v)</span>:</span>
        node=self.root
        self.root=self.insert(node,k,v)
        self.root.color=BLACK

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self,k)</span>:</span>
        <span class="hljs-keyword">return</span> self.search(self.root,k)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self,node,k,v)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> Node(k,v)

        <span class="hljs-keyword">if</span> k==node.key:
            node.value=v
        <span class="hljs-keyword">elif</span> k&lt;node.key:
            node.lchild=self.insert(node.lchild,k,v)
        <span class="hljs-keyword">else</span>:
            node.rchild=self.insert(node.rchild,k,v)
        
        <span class="hljs-keyword">if</span>(self.is_red(node.rchild)):           <span class="hljs-comment">#右红变左红</span>
            node=self.rotateLeft(node)

        <span class="hljs-keyword">if</span>(self.is_red(node.lchild) <span class="hljs-keyword">and</span> self.is_red(node.lchild.lchild)):   <span class="hljs-comment">#连续左红就要右转</span>
            node=self.rotateRight(node)
        
        
        <span class="hljs-keyword">if</span>(self.is_red(node.lchild) <span class="hljs-keyword">and</span> self.is_red(node.rchild)):  <span class="hljs-comment">#两孩子都红，需要翻转颜色</span>
            self.colorFlip(node)

        <span class="hljs-keyword">return</span> node

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self,node,x)</span>:</span>
        current_node=node
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_node:
                result=<span class="hljs-literal">None</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">elif</span> x&lt;current_node.key:
                current_node=current_node.lchild
            <span class="hljs-keyword">elif</span> x&gt;current_node.key:
                current_node=current_node.rchild
            <span class="hljs-keyword">else</span>:
                result=current_node
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> result:
            <span class="hljs-keyword">return</span> result.value
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotateLeft</span><span class="hljs-params">(self,h)</span>:</span>
        node=h.rchild
        h.rchild=node.lchild
        node.lchild=h
        node.color=node.lchild.color
        node.lchild.color=RED
        <span class="hljs-keyword">return</span> node

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotateRight</span><span class="hljs-params">(self,h)</span>:</span>
        node=h.lchild
        h.lchild=node.rchild
        node.rchild=h
        node.color=node.rchild.color
        node.rchild.color=RED
        <span class="hljs-keyword">return</span> node

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">colorFlip</span><span class="hljs-params">(self,h)</span>:</span>  <span class="hljs-comment">#翻转颜色函数</span>
        h.color= <span class="hljs-keyword">not</span> h.color
        h.lchild.color=<span class="hljs-keyword">not</span> h.lchild.color
        h.rchild.color=<span class="hljs-keyword">not</span> h.rchild.color
        <span class="hljs-keyword">return</span> h
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fixUp</span><span class="hljs-params">(self,h)</span>:</span>      <span class="hljs-comment">#删除时，用到的往上修复的函数</span>
        <span class="hljs-keyword">if</span> self.is_red(h.rchild):
            h=self.rotateLeft(h)

        <span class="hljs-keyword">if</span> self.is_red(h.lchild) <span class="hljs-keyword">and</span> self.is_red(h.lchild.lchild):
            h=self.rotateRight(h)

        <span class="hljs-keyword">if</span> self.is_red(h.lchild) <span class="hljs-keyword">and</span> self.is_red(h.rchild):
            h=self.colorFlip(h)
        
        <span class="hljs-keyword">return</span> h

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">moveRedRight</span><span class="hljs-params">(self,h)</span>:</span>   <span class="hljs-comment">#删除时右路查询的情况</span>
        self.colorFlip(h)
        <span class="hljs-keyword">if</span> self.is_red(h.lchild.lchild):
            h=self.rotateRight(h)
            self.colorFlip(h)
        <span class="hljs-keyword">return</span> h

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">moveRedLeft</span><span class="hljs-params">(self,h)</span>:</span>    <span class="hljs-comment">#删除时左路查询的情况</span>
        self.colorFlip(h)
        <span class="hljs-keyword">if</span> self.is_red(h.rchild.lchild):
            h.rchild=self.rotateRight(h.rchild)
            h=self.rotateLeft(h)
            self.colorFlip(h)
        <span class="hljs-keyword">return</span> h

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">(self,h)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> h.lchild:           <span class="hljs-comment">##为何，因为不可能出现黑节点在右而左节点为空的情况。而在LLRBT里，红节点一直在左</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        <span class="hljs-keyword">if</span> self.is_red(h.lchild) <span class="hljs-keyword">and</span> self.is_red(h.lchild.lchild):
            h=self.moveRedLeft(h)

        h.lchild=self.deleteMin(h.lchild)
        <span class="hljs-keyword">return</span> self.fixUp(h)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self,k)</span>:</span>
        self.root = self.delete(self.root, k)
        self.root.color = BLACK

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self,h,k)</span>:</span>
        <span class="hljs-keyword">if</span> k&lt;h.key:
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> self.is_red(h.lchild) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.is_red(h.lchild.lchild)):
                h=self.moveRedLeft(h)
            h.lchild=self.delete(h.lchild,k)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> self.is_red(h.lchild):
                h=self.rotateRight(h)
            <span class="hljs-keyword">if</span> k==h.key <span class="hljs-keyword">and</span> h.rchild==<span class="hljs-literal">None</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_red(h.rchild) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.is_red(h.rchild.lchild):
                h=self.moveRedRight(h)
            <span class="hljs-keyword">if</span> k==h.key:
                h.key=self.min(h.rchild)
                h.value=self.search(h.rchild,h.key)
                h.rchild=self.deleteMin(h.rchild)
            <span class="hljs-keyword">else</span>:
                h.rchild=self.delete(h.rchild,k)
        <span class="hljs-keyword">return</span> self.fixUp(h)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span>      <span class="hljs-comment">#查询最小节点</span>
        <span class="hljs-keyword">if</span> (self.root == <span class="hljs-literal">None</span>): 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:              
            <span class="hljs-keyword">return</span> min(self.root)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self, x)</span>:</span>   <span class="hljs-comment">#查询某子树的最小节点</span>
        <span class="hljs-keyword">if</span> (x.lchild == <span class="hljs-literal">None</span>): 
            <span class="hljs-keyword">return</span> x.key
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.min(x.lchild)
</code></pre>
<p>可能想比一下AVL跟LLRBT的性能，那就pk一下，因为实现的有差异，可能不是很客观，仅供娱乐。</p>
<ul>
<li>随机300个数据：
<img src="/images/a_r_pk_300.png" alt="test-1"></li>
</ul>
<ul>
<li>随机3000个数据：
<img src="/images/a_r_pk_3000.png" alt="test-2"></li>
</ul>
<ul>
<li>随机30000个数据：
<img src="/images/a_r_pk_30000.png" alt="test-3"></li>
</ul>
<p>结果LLRBT竟然遭到无情暴击。。。看来还有待优化。到这里，有关红黑树的知识就介绍完了。</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#二叉查找树">二叉查找树</a></li><li><a href="#平衡二叉树">平衡二叉树</a><ul class="toc-headings"><li><a href="#avl树">AVL树</a></li></ul></li><li><a href="#再遇红黑树">再遇红黑树</a><ul class="toc-headings"><li><a href="#红黑树的性质">红黑树的性质</a></li></ul></li><li><a href="#2-3tree">2-3Tree</a><ul class="toc-headings"><li><a href="#2-3tree查找">2-3Tree查找</a></li><li><a href="#2-3tree插入">2-3Tree插入</a></li></ul></li><li><a href="#2-3树到红黑树">2-3树到红黑树</a><ul class="toc-headings"><li><a href="#树旋转操作">树旋转操作</a></li><li><a href="#插入操作">插入操作</a></li><li><a href="#删除操作">删除操作</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/blog-resources/" class="nav-home"><img src="/blog-resources/img/favicon.ico" alt="Sakura&#x27;s blog" width="66" height="58"/></a><div><h5>Docs</h5><a href="/blog-resources/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/blog-resources/docs/en/doc2.html">Guides (or other categories)</a><a href="/blog-resources/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/blog-resources/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog-resources/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/blog-resources/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2019 Lee Sure(SakuraWood)</section></footer></div></body></html>